<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>코딩테스트 기록</title>
    <style>
        
    </style>
</head>
<body>
    <script>
        // 배열 자르기 splice 와 slice 학습
        function solution(numbers, num1, num2) {
            var answer = [];
            answer = numbers.slice(num1,num2+1)
            console.log(answer);
        }
        function solution(numbers, num1, num2) {
            var answer = [];
            answer = numbers.splice(num1,num2-num1+1)
            console.log(answer);
        }
        // includes 함수  문자열 안에 해당문자열이 있으면 true 없으면 false 를 반환
        function solution(str1, str2) {
            var answer = 0;
            answer = str1.includes(str2);
            if(answer==true){
                answer = 1
            } else {
                answer = 2
            }
            return answer;
        }
        // 내가 푼 방식
        function solution(price) {
            var answer = 0;
            if(price >= 100000 && price < 300000){
                answer = price*0.95
            } else if(price >= 300000 && price < 500000){
                answer = price*0.9
            } else if(price >= 500000){
                answer = price*0.8
            }
            return Math.floor(answer);
        }
        // 다른 사람이 푼 방식
        function solution(price) {
            price = price>=500000?price*0.8:price>=300000?price*0.9:price>=100000?price*0.95:price;
            return ~~(price);
        }
        // 삼항 연산자를 좀 더 잘 쓰게 공부해야 할듯.
        
        // 배열의 중앙값을 return 하도록 하는 문제, sort() 와 /2를 사용하니 배열이 1일 경우 추가
        function solution(array) {
            var answer = 0;
            array = array.sort((a,b)=>a-b);
            array.length != 1 ? answer=array[Math.floor(array.length/2)] : answer = array[0] 
            return answer;
        }

        // 배열 s1, s2 가 몇 개나 같은 값을 가지고 있는지 return 하는 문젲
        function solution(s1, s2) {
            var answer = 0;
            answer = s1.filter((a)=> s2.includes(a)).length;
            return answer;
        }
        // filter 와 includes 를 알고 있어서 쉽게 해결할 수 있었다.

        // 정수 n 이 주어졌을 때 각 자릿수의 n 을 모두 더하는 문제
        function solution(n) {
            var answer = 0;
            array = [...String(n)]
            for(var i=0; i<array.length; i++){
                answer += Number(array[i]);
            }
            console.log(answer);
        }
        solution(1234);
        // 형변환은 이해했지만 배열을 더하는 것이니 reduce를 쓰면 좀더 좋았것다 ㅜ

        // 정수 n 이 주어질때 순서쌍 a*b가 n 개인 개수를 리턴하는 문제
        function solution(n) {
            var answer = 0;
            array = [];
            for(i=n; i>0; i--){
                array.push(i);
            }
            answer = array.filter((a)=> n%a==0).length;
            console.log(answer);
        }
        solution(20);
        // n이하인 정수를 push 하고 배열을 return 해서 풀었다. 수학 더잘하는 사람은 더 깔끔하게 풀은듯..

        // 주어진 정수 n 이 제곱근인지 판별하는 코딩 테스트
        function solution(n) {
            var answer = 0;
            n==1 ? answer= 1 : Math.sqrt(n)%1===0 ? answer = 1 : answer = 2
            console.log(answer);
        }
        solution(1);
        // 루트 문제일거라 생각해 sqrt 함수를 새로 공부했고 , isInteger 은 이제 지원안하나보다
        //  그래서 sqrt 로 나온 걸 1로 나눠서 나머지가 0인지 판별했다.

        // 영어 문자열에서 a, e , i, o, u 를 빼고 리턴하는문제.
        function solution(my_string) {
            var answer = '';
            array = ['a','e','i','o','u']
            answer = [...my_string].filter((a) => !array.includes(a)).join('');
            console.log(answer);
        }
        solution('nice to meet you')
        // 나는 filter 와 includes를 썼는데 replace 와 정규표현식으로 간단하게 해결한 사람이 있다.

        // 문자열에 안에 존재하는 숫자를 찾아 더해서 return 하는 함수
        function solution(my_string) {
            var answer = '';
            answer = [...my_string].filter((a)=> /[0-9]/.test(a)).reduce((a,b)=> Number(a)+Number(b));
            console.log(answer);
        }
        solution('aAb1B2cC34oOp')
        // 정규표현식과 필터 리듀스를 사용했는데, 다른사람들도 거의 비슷하게 한것 같다. 정규표현식 사용법만 조금 달드ㅏ.
    
        // 개미군단 문제
        function solution(hp) {
            answer = 0;
            var a = Math.floor(hp/5);
            var b = hp%5;
            var c = Math.floor(b/3);
            var d = b%3/1;
            answer = a+c+d;
            console.log(answer);
        }
        solution(23)
        // 나누기하고...나머지구하고..거기서 또 나누고 아주 더럽게 풀었다.. 근데 다른사람들 풀이보니까 다비슷하다.
    
        // 배열 numlist 가 있을때 n 의 배수만 return 하는 문제
        function solution(n, numlist) {
            var answer = [];
            answer = numlist.filter((a)=> a%n==0);
            console.log(answer);
        }
        solution(3,[4,5,6,7,8,9,10,11,12]);
        // 머..filter랑 나머지연산을 이용한거 이제 이쯤오면 쉽다.

        // 대소문자 변환
        function solution(my_string) {
            var answer = '';
            array = [...my_string];
            array2 = [];
            for(var i=0; i<array.length; i++){
                if(/[a-z]/.test(array[i])){
                    array2.push(array[i].toUpperCase());
                }else{
                    array2.push(array[i].toLowerCase());
                }
            }
            console.log(array2)
            answer = array2.join('');
            console.log(answer);
        }
        solution('AabBBcdedeETE');
        // 정말 그지같이 풀었다.. 나는 바보다 ..

        // 정수 n 이 주어질때 t 만큼 두배로 늘어난거 구하는 문제
        function solution(n, t) {
            var answer = 0;
            var n = n;
            for(var i=0; i<t; i++){
                n = n*2
            }
            answer = n
            console.log(answer);
        }
        solution(3,5);
        //  이걸 다른 사람이 푼거 시프트 연산자..진짜 첨봐따...
        function solution(n, t) {
            return n << t;
        }
        // 군 전략가 머쓱이는 전쟁 중 적군이 다음과 같은 암호 체계를 사용한다는 것을 알아냈습니다.

        // 암호화된 문자열 cipher를 주고받습니다.
        // 그 문자열에서 code의 배수 번째 글자만 진짜 암호입니다.
        // 문자열 cipher와 정수 code가 매개변수로 주어질 때 해독된 암호 문자열을 return하도록 solution 함수를 완성해주세요.
        function solution(cipher, code) {
            var answer = '';
            for(i=code-1; i<cipher.length; i+=code){
                answer += [...cipher][i];
            }
            console.log(answer);
        }
        solution('dfjardstddetckdaccccdegk',4);
         // 가위는 2 바위는 0 보는 5로 표현합니다. 가위 바위 보를 내는 순서대로 나타낸 문자열 rsp가 매개변수로 주어질 때, rsp에 저장된 가위 바위 보를 모두 이기는 경우를 순서대로 나타낸 문자열을 return하도록 solution 함수를 완성해보세요.
         function solution(rsp) {
            var answer = '';
            answer = [...rsp].map((a)=>{
                if(a==='2'){
                    return 0;
                }else if(a==='5'){
                    return 2;
                }else{
                    return 5;
                }
            })
            console.log(answer);
        }
        solution("205052");
        //  상자의 가로, 세로, 높이가 저장되어있는 배열 box와 주사위 모서리의 길이 정수 n이 매개변수로 주어졌을 때, 상자에 들어갈 수 있는 주사위의 최대 개수를 return 하도록 solution 함수를 완성해주세요.
        function solution(box, n) {
            var answer = box.map((a) => Math.floor(a/n)).reduce((a,b)=> a*b);
            console.log(answer);
        }
        solution([6,8,10], 3);
        // 문자열에서 숫자만 빼서 오름차순 정렬
        function solution(my_string) {
            var answer = ([...my_string].map(Number)).filter((a)=> !isNaN(a)).sort();
            console.log(answer);
        }
        solution('abcde0');
         // 정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.
         function solution(n) {
            var answer = 0;
            for(let i=n; i>0; i--){
                if(n%i==0){
                    answer += i;
                }
            }
            return answer;
        }
        solution(13);
         //배열 numbers의 원소를 direction방향으로 한 칸씩 회전시킨 배열을 return하도록 solution 함수를 완성해주세요.
         function solution(numbers, direction) {
            var answer = [];
            direction==="right" ? numbers.unshift(numbers.pop()) : numbers.push(numbers.shift());
            answer = numbers;
            console.log(answer);
        }
        solution([4, 455, 6, 4, -1, 45, 6],'right');
        //자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.
        function solution(n) {
            var answer = [];
            n = [...String(n)];
            for(var i=n.length; i>0; i--){
                answer.push(Number(n[i-1]));
            }
            console.log(answer);
        }
        solution(123456);
        //정수 배열 array가 매개변수로 주어질 때, 가장 큰 수와 그 수의 인덱스를 담은 배열을 return 하도록 solution 함수를 완성해보세요.


        function solution(array) {
            var answer = [];
            var ex = [...array];
            answer[0] = (ex.sort((a,b) => b-a)[0]); 
            answer[1] = array.indexOf(answer[0]);
            console.log(answer);
        }
        solution([9,10,11,8]);
        //n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.


        function solution(n) {
            var answer = 0;
            var cnt = Math.sqrt(n);
            cnt%1===0 ? answer = (cnt+1)*(cnt+1) : answer = -1;
            console.log(answer);
        }
        solution(121);
        //n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.


        function solution(s) {
            var answer = '';
            var as = [...s.toLowerCase()];
            var p = 0;
            var y = 0;
            console.log(as);
            for(var i of as){
               if(i=='p'){
                p++;
               }
               if(i=='y'){
                y++;
               }
            }
            p==y || p+y==0 ? answer=true : answer=false;
            console.log(answer);
        }
        solution('Pyy');

        // 알파벳으로 이루어진 문자열 myString이 주어집니다. 모든 알파벳을 소문자로 변환하여 return 하는 solution 함수를 완성해 주세요.
        function solution(myString) {
            return myString.toLowerCase();
        }

        // 한 자리 정수로 이루어진 문자열 num_str이 주어질 때, 각 자리수의 합을 return하도록 solution 함수를 완성해주세요.
        function solution(num_str) {
            var answer = num_str.split('').reduce((a,b) => Number(a)+Number(b))
            return answer;
        }

        // 알파벳으로 이루어진 문자열 myString이 주어집니다. 모든 알파벳을 대문자로 변환하여 return 하는 solution 함수를 완성해 주세요.
        function solution(myString) {
            return myString.toUpperCase();
        }
 
        //정수 number와 n, m이 주어집니다. number가 n의 배수이면서 m의 배수이면 1을 아니라면 0을 return하도록 solution 함수를 완성해주세요.
        function solution(number, n, m) {
            var answer = number%n == 0 && number%m == 0 ? 1 : 0
            return answer;
        }

        // 실수 flo가 매개 변수로 주어질 때, flo의 정수 부분을 return하도록 solution 함수를 완성해주세요.
        function solution(flo) {
            return parseInt(flo)
        }

        //부분 문자열이란 문자열에서 연속된 일부분에 해당하는 문자열을 의미합니다. 예를 들어, 문자열 "ana", "ban", "anana", "banana", "n"는 모두 문자열 "banana"의 부분 문자열이지만, "aaa", "bnana", "wxyz"는 모두 "banana"의 부분 문자열이 아닙니다.
        //문자열 my_string과 target이 매개변수로 주어질 때, target이 문자열 my_string의 부분 문자열이라면 1을, 아니라면 0을 return 하는 solution 함수를 작성해 주세요.
        function solution(my_string, target) {
            return my_string.includes(target) ? 1 : 0
        }

        // 정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 n 번째 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.
        function solution(num_list, n) {
            var answer = [];
            for(var i=0; i<n; i++){
                answer.push(num_list[i])
            }
            return answer;
        }

        // 문자열 my_string과 정수 k가 주어질 때, my_string을 k번 반복한 문자열을 return 하는 solution 함수를 작성해 주세요.
        function solution(my_string, k){
            return my_string.repeat(k)
        }

        //정수 배열 arr와 자연수 k가 주어집니다. 만약 k가 홀수라면 arr의 모든 원소에 k를 곱하고, k가 짝수라면 arr의 모든 원소에 k를 더합니다. 이러한 변환을 마친 후의 arr를 return 하는 solution 함수를 완성해 주세요.
        function solution(arr, k) {
            var answer = k%2===0 ? arr.map(el => el+k) : arr.map(el => el*k);
            return answer;
        }
 
        // 정수 num과 n이 매개 변수로 주어질 때, num이 n의 배수이면 1을 return n의 배수가 아니라면 0을 return하도록 solution 함수를 완성해주세요.
        function solution(num, n) {
            var answer = num%n === 0 ? 1 : 0
            return answer;
        }

        //1부터 6까지 숫자가 적힌 주사위가 두 개 있습니다. 두 주사위를 굴렸을 때 나온 숫자를 각각 a, b라고 했을 때 얻는 점수는 다음과 같습니다.
        // a와 b가 모두 홀수라면 a2 + b2 점을 얻습니다.
        // a와 b 중 하나만 홀수라면 2 × (a + b) 점을 얻습니다.
        // a와 b 모두 홀수가 아니라면 |a - b| 점을 얻습니다.
        // 두 정수 a와 b가 매개변수로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요.
        function solution(a, b) {
            let Na = a%2;
            let Nb = b%2
            var answer = 0;
            
            if(Na === 1 && Nb === 1){
                answer = a**2 + b**2    
            }else if(Na === 0 && Nb === 0){
                answer = (a+b)*2
            }else{
                answer = Math.abs(a-b)
            }
            
            return answer;
        }

        // 문자들이 담겨있는 배열 arr가 주어집니다. arr의 원소들을 순서대로 이어 붙인 문자열을 return 하는 solution함수를 작성해 주세요.
        function solution(arr) {
            var answer = arr.join('');
            return answer;
        }

        // 두 정수 a, b와 boolean 변수 flag가 매개변수로 주어질 때, flag가 true면 a + b를 false면 a - b를 return 하는 solution 함수를 작성해 주세요.
        function solution(a, b, flag) {
            var answer = flag ? a+b : a-b
            return answer;
        }

        // 정수 start와 end가 주어질 때, start부터 end까지의 숫자를 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.
        function solution(start, end) {
            var answer = [];
            for(var i = start; i<end; i++){
                answer.push(i);
            }
            return answer;
        }

        // 문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 앞의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.
        function solution(my_string, n) {
            var answer = my_string.slice(0,n)
            return answer;
        }

        // 정수 리스트 num_list와 정수 n이 주어질 때, n 번째 원소부터 마지막 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.
        function solution(num_list, n) {
            var answer = num_list.slice(n-1);
            return answer;
        }

        // 문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 뒤의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.
        function solution(my_string, n) {
            var answer = my_string.slice(-n);
            return answer;
        }

        // 정수가 담긴 리스트 num_list가 주어질 때, 리스트의 길이가 11 이상이면 리스트에 있는 모든 원소의 합을 10 이하이면 모든 원소의 곱을 return하도록 solution 함수를 완성해주세요.
        function solution(num_list) {
            var answer = 0;
            var length = num_list.length;
            
            if(length >= 11){
                answer = num_list.reduce((a,b) => a+b);
            }else{
                answer = num_list.reduce((a,b) => a*b);
            }
           
            return answer;
        }

        // 문자 "A"와 "B"로 이루어진 문자열 myString과 pat가 주어집니다. myString의 "A"를 "B"로, "B"를 "A"로 바꾼 문자열의 연속하는 부분 문자열 중 pat이 있으면 1을 아니면 0을 return 하는 solution 함수를 완성하세요.
        function solution(myString, pat) {
            var answer = myString.map((el) => el === 'A' ? el='B' : el+'A').includes(pat) ? 1 : 0;
            return answer;
        }

        // 정수 리스트 num_list와 찾으려는 정수 n이 주어질 때, num_list안에 n이 있으면 1을 없으면 0을 return하도록 solution 함수를 완성해주세요.
        function solution(num_list, n) {
            var answer = num_list.includes(n) ? 1 : 0;
            return answer;
        }

        // 어떤 문자열 A가 다른 문자열 B안에 속하면 A를 B의 부분 문자열이라고 합니다. 예를 들어 문자열 "abc"는 문자열 "aabcc"의 부분 문자열입니다. 문자열 str1과 str2가 주어질 때, str1이 str2의 부분 문자열이라면 1을 부분 문자열이 아니라면 0을 return하도록 solution 함수를 완성해주세요.
        function solution(str1, str2) {
            var answer = str2.includes(str1) ? 1 : 0;
            return answer;
        }

        // 정수 배열 numbers와 정수 n이 매개변수로 주어집니다. numbers의 원소를 앞에서부터 하나씩 더하다가 그 합이 n보다 커지는 순간 이때까지 더했던 원소들의 합을 return 하는 solution 함수를 작성해 주세요.

        function solution(numbers, n) {
            var answer = 0;
            
            const plus = (count , m) => {
                if(m > n){
                    return m;
                }else{
                    return plus(count+1 , m+numbers[count])
                }
            }
            
            console.log(plus(0,0));
        }

        // 문자열 배열 strArr가 주어집니다. 모든 원소가 알파벳으로만 이루어져 있을 때, 배열에서 홀수번째 인덱스의 문자열은 모든 문자를 대문자로, 짝수번째 인덱스의 문자열은 모든 문자를 소문자로 바꿔서 반환하는 solution 함수를 완성해 주세요.

        function solution(strArr) {
            var answer = strArr.map((el,i) => {
                return i%2 === 0 ? el.toLowerCase() : el.toUpperCase();
            })
            
            console.log(answer);
        }

        // 정수가 담긴 리스트 num_list가 주어질 때, 모든 원소들의 곱이 모든 원소들의 합의 제곱보다 작으면 1을 크면 0을 return하도록 solution 함수를 완성해주세요.
        
        function solution(num_list) {
            var answer = num_list.reduce((a,b)=> a*b) < num_list.reduce((a,b) => a+b)**2 ? 1 : 0;
            
            return answer;
        }

        // 정수 start와 end가 주어질 때, start에서 end까지 1씩 감소하는 수들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.

        function solution(start, end) {
            var answer = [];
            
            for(let i = start; i>=end ; i--){
                answer.push(i);
            }
            
            return answer;
        }

        // 수 조작히기
        function solution(n, control) {
            [...control].forEach(el => {
                if (el === 'w') {
                n = n + 1;
                }
                if (el === 's') {
                n = n - 1;
                }
                if (el === 'd') {
                n = n + 10;
                }
                if (el === 'a') {
                n = n - 10;
                }
            });
            return n;
        }

        // 정수 리스트 num_list가 주어질 때, 첫 번째로 나오는 음수의 인덱스를 return하도록 solution 함수를 완성해주세요. 음수가 없다면 -1을 return합니다.
        function solution(num_list) {
            var answer = -1;
            
            for(let i=0; i<num_list.length; i++){
                if(num_list[i] < 0) {
                    answer = i
                    break;
                }
            }

            console.log(answer); 
        }

        // 마지막 두 원소
        function solution(num_list) {
            var answer = [...num_list];
            var length = num_list.length;
            var last = answer[length-1];
            var front = answer[length-2]

            if(last > front){
                answer.push(last-front);
            }else{
                answer.push(last*2)
            }
            
            console.log(answer);
        }

        // 단어가 공백 한 개로 구분되어 있는 문자열 my_string이 매개변수로 주어질 때, my_string에 나온 단어를 앞에서부터 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.
        function solution(my_string) {
            var answer = my_string.split(' ');
            console.log(answer);
        }

        // 연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다.
        // 12 ⊕ 3 = 123
        // 3 ⊕ 12 = 312
        // 양의 정수 a와 b가 주어졌을 때, a ⊕ b와 b ⊕ a 중 더 큰 값을 return 하는 solution 함수를 완성해 주세요.
        // 단, a ⊕ b와 b ⊕ a가 같다면 a ⊕ b를 return 합니다.

        function solution(a, b) {
            var answer = 0;
            let ab = Number(''+a+b);
            let ba = Number(''+b+a);
            
            ab > ba ? answer = ab : ba > ab ? answer = ba : answer = ab;
            
            return answer;
        }

        // 양의 정수 n이 매개변수로 주어질 때, n이 홀수라면 n 이하의 홀수인 모든 양의 정수의 합을 return 하고 n이 짝수라면 n 이하의 짝수인 모든 양의 정수의 제곱의 합을 return 하는 solution 함수를 작성해 주세요.

        function solution(n) {
            var answer = 0;
                    if(n%2 === 0){
                        for(let i=0; i<=n; i++){
                            if(i%2 === 0){
                                answer += i**2;
                            }
                        }
                    }
                    if(n%2 === 1){
                        for(let i=0; i<=n; i++){
                            if(i%2 === 1){
                                answer += i;
                            }
                        }
                    }
            
            return answer;
        }

        // 정수가 담긴 리스트 num_list가 주어집니다. num_list의 홀수만 순서대로 이어 붙인 수와 짝수만 순서대로 이어 붙인 수의 합을 return하도록 solution 함수를 완성해주세요.
        function solution(num_list) {
            var answer = Number(num_list.filter(e => e%2 === 1).join('')) + Number(num_list.filter(e => e%2 === 0).join(''))
            return answer;
        }
        // 정수로 이루어진 리스트 num_list가 주어집니다. num_list에서 가장 작은 5개의 수를 제외한 수들을 오름차순으로 담은 리스트를 return하도록 solution 함수를 완성해주세요.
        function solution(num_list) {
            var answer = num_list.sort((a,b) => a-b).slice(5);
           console.log(answer);
        }

        // 'm'과 "rn"이 모양이 비슷하게 생긴 점을 활용해 문자열에 장난을 하려고 합니다. 문자열 rny_string이 주어질 때, rny_string의 모든 'm'을 "rn"으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요.

        function solution(rny_string) {
            var answer = rny_string.replace('m' , 'rn');
            return answer;
        }

        // 특정한 문자를 대문자로 바꾸기
        function solution(my_string, alp) {
            return [...my_string].map(el => {
                return el === alp ? el.toUpperCase() : el
            }).join('')
        }

        // 뒤에서 5등까지
        function solution(num_list) {
            return num_list.sort((a,b) => a-b).slice(0,5)
        }

        // 접두사인지 확인하기
        function solution(my_string, is_prefix) {
            return my_string.slice(0,is_prefix.length) === is_prefix ? 1 : 0
        }

        // 조건에 맞게 수열 변환하기 1
        function solution(arr) {
            return arr.map(el => {
                if(el >= 50 && el%2==0){
                    return el/2
                }
                if(el < 50 && el%2==1){
                    return el*2
                }
                return el
            })
        }

        // 원하는 문자열 찾기 
        function solution(myString, pat) {
            return myString.toUpperCase().includes(pat.toUpperCase()) ? 1 : 0;
        }

        // 글자 이어 붙여 문자열 만들기
        function solution(my_string, index_list) {
            return index_list.map(el => {
                return my_string[el]
            }).join('')
        }

        // 배열의 원소만큼 추가하기
        function solution(arr) {
            var answer = [];
            arr.map(el => {
                for(i=0 ; i<el; i++){
                    answer.push(el)
                }
            })
            return answer;
        }

        // 배열 만들기 1
        function solution(n, k) {
            var answer = [];
            for(i=k; i<=n; i += k){
                answer.push(i);
            }
            return answer;
        }

        // 접미사인지 확인하기
        function solution(my_string, is_suffix) {
            return my_string.endsWith(is_suffix) ? 1 : 0;
        }

        // A 강조하기
        const solution=s=>s.toLowerCase().replaceAll('a','A');

        // n개 간격의 원소들
        function solution(num_list, n) {
            var answer = [];
            for(i=0; i<num_list.length; i+=n){
                answer.push(num_list[i])
            }
            return answer;
        }

        // 홀수 vs 짝수
        function solution(num_list, n) {
            var answer = [];
            for(i=0; i<num_list.length; i+=n){
                answer.push(num_list[i])
            }
            return answer;
        }

        // 꼬리 문자열
        function solution(str_list, ex) {
            return str_list.filter(el => !el.includes(ex)).join('');
        }

        // 최댓값 만들기 (2)
        function solution(numbers) {
            let sort_numbers = numbers.sort((a,b) => a-b);
            
            return Math.max(sort_numbers[0]*sort_numbers[1], sort_numbers[sort_numbers.length-1]*sort_numbers[sort_numbers.length-2]);
        }

        // 공백으로 구분하기 2
        function solution(my_string) {
            console.log(my_string.split(' ').filter(v=> v))
        }

        // 배열의 길이에 따라 다른 연산하기
        function solution(arr, n) {
            var answer = [];
            if(arr.length%2 == 0){
            answer = arr.map((el,i)=>{
                    if(i%2 == 1){
                        return el+n
                    }
                    return el
                })
            }else{
            answer =  arr.map((el,i)=>{
                    if(i%2== 0){
                        return el+n
                    }
                    return el
                })
            }
            
            return answer;
        }

        // 부분 문자열 이어 붙여 문자열 만들기
        function solution(my_strings, parts) {
            return my_strings.map((el,i)=>{
                        return [...el].slice(parts[i][0],parts[i][1]+1).join('')
                    }).join('')
        }

        // 배열 비교하기
        function solution(arr1, arr2) {
            var answer = 0;
            let arr1Num = arr1.length;
            let arr2Num = arr2.length;
            let arr1Total = arr1.reduce((a,b) => a+b);
            let arr2Total = arr2.reduce((a,b) => a+b);
            
            arr1Num > arr2Num ? answer = 1 : arr1Num < arr2Num ? answer = -1 : arr1Total > arr2Total ? answer =1 : arr1Total > arr2Total ? answer = 1 : arr1Total < arr2Total ? answer = -1 : answer = 0
            
            
            return answer;
        }

        // 외계행성의 나이

        function solution(age) {
            return [...age+""].map(el => {
                        return String.fromCharCode(Number(el)+97)
                    }).join('')
        }

        // 피자 나눠 먹기 (2)
            function solution(n) {
                const gcd = (a,b) => {
                    if(b === 0){
                        return a
                    }
                    return gcd(b, a%b)
                }
                return (n*6 / gcd(n,6))/6
            }
        
        // ﻿접미사 배열
        function solution(my_string) {
            var answer = [];
            for( i = 0; i<my_string.length; i++){
                answer.push(my_string.slice(i))
            }
            return answer.sort();
        }

        // I로 만들기
        function solution(myString) {
            const ASCII_I = 'l'.charCodeAt()
            
            return [...myString].map(el => {
                if(String(el).charCodeAt() < ASCII_I){
                    return 'l'
                }
                return el
            }).join('');
        }

        // 0 떼기
        const solution = (str) => String(Number(str))

        // x만큼 간격이 있는 n개의 숫자
        function solution(x, n) {
            var answer = [];
            for(i=1; i<=n; i++){
                answer.push(x*i)
            }
            return answer;
        }

        // 나머지가 1이 되는 수 찾기
        function solution(n) {
            var answer = 0;
            for(i=2; i<n; i++){
                if((n-1)%i === 0){
                    answer = i
                    break;
                }
            }
            return answer;
        }

        // 순서 바꾸기
        function solution(num_list, n) {
            return [...num_list.slice(n) , ...num_list.slice(0,n)]
        }

        // 5명씩
        function solution(names) {
            var answer = [];
            for(i= 0; i<names.length; i +=5){
            answer.push(names[i]) 
            }
            return answer;
        }

        // 할 일 목록
        function solution(todo_list, finished) {
            return todo_list.filter((_,i)=> 
                        finished[i] === true
                    );
        }

        // 배열의 원소 삭제하기
        function solution(arr, delete_list) {
            return arr.filter(el => !delete_list.includes(el));
        }

        // ad 제거하기
        function solution(strArr) {
            return strArr.filter(el => {
                return !el.includes('ad')
            });
        }

        // 수 조작하기 2
        function solution(numLog) {
            var answer = '';
            
            for(var i=0; i<numLog.length-1; i++){
                var word = numLog[i+1] - numLog[i]

                if(word === 1){
                    answer += 'w'
                }
                if(word === -1){
                    answer += 's'
                }
                if(word === 10){
                    answer += 'd'
                }
                if(word === -10){
                    answer += 'a'
                }
            }

            return answer;
        } 
        // 배열만들기 
        function solution(intStrs, k, s, l) {
            return intStrs.map(el => Number(el.slice(s,s+l))).filter(el => el>k);
        }

        // 수열과 구간 쿼리
        function solution(arr, queries) {
    
            queries.forEach(el => {
                for(let i=el[0]; i<=el[1]; i++){
                    arr[i] = arr[i]+1
                }
            });
            return arr 
        }

        // 날짜 비교하기
        function solution(date1, date2) {
            const [year1, month1, day1] = date1
            const [year2, month2, day2] = date2
            if(year1 !== year2) return year1 < year2 ? 1 : 0
            if(month1 !== month2) return month1 < month2 ? 1 : 0
            if(day1 !== day2) return day1 < day2 ? 1 : 0
            return 0
        }
        // k의 개수
        function solution(i, j, k) {
            var answer = 0;
            
            for (let index = i; index<=j; index++){
                [...index+''].map(el => {
                    if(el==k) answer++
                })
                console.log([...index+''])
            }
            return answer;
        }

        // 가까운 수
        function solution(array, n) {
            var answer = 0;
            var diff = 200;
            array.sort((a,b)=>b-a).forEach(el => {
                if(Math.abs(n-el) <= diff){
                    diff = Math.abs(n-el)
                    answer = el
                }
            })
            return answer;
        }
        // 글자 지우기
        function solution(my_string, indices) {
            return [...my_string].filter((_,i) => !indices.includes(i) ).join('');
        }
        // 가장 작은 값 제거
        if(arr.length === 1){
                return -1
            }
            var answer = [];
            var min = Math.min(...arr);
            
            answer = arr.filter(el => el !== min)
            
        return answer;
        //진료 순서 정하기
        function solution(emergency) {
            var rank = [...emergency].sort((a,b) => b-a) 
            return emergency.map(el => {
                return rank.indexOf(el)+1
            })
        }
        // 숨어 있는 숫자의 덧셈
        function solution(my_string) {
            var answer = my_string.match(/\d+/g)
            var sum = 0;
            if(answer){
                answer.forEach(el => {
                    sum += parseInt(el)
                })    
            }

            return sum
        }
        // 세로 읽기
        function solution(my_string, m, c) {
            var answer = ''
            
            for(var i = c; i<=my_string.length; i += m){
                answer += my_string[i-1]
            }
            
            return answer;
        }
        // 수열과 구간쿼리 3
        function solution(arr, queries) {
            var answer = [...arr];
            
            queries.forEach(el => {
                let newArr = [...answer];
                let stack = newArr[el[0]];
                
                newArr[el[0]] = newArr[el[1]];
                newArr[el[1]] = stack;
                
                answer = newArr
            })
            
            return answer;
        }
        // 이차연 배열 대각선 순회하기
        function solution(board, k) {
            var answer = 0;
        
            for(var i=0; i<board.length; i++){
                for(var j=0; j<=board[i].length; j++){
                    if(i+j < k){
                        answer += board[i][j]
                    }
                }
            }
            return answer;
        }
        // 1로 만들기
        function solution(num_list) {
            answer = 0;
            
            const cur = (number,count) => {
                if(number === 1){
                    answer += count
                    return    
                }
                if(number%2 === 0){
                    return cur(number/2,count+1)
                }
                if(number%2 === 1){
                    return cur((number-1)/2,count+1)
                }
            }
            
            num_list.forEach(el => {
                cur(el,0)
            })
                
            return answer
        }
        // 특정 문자열로 끝나는 가장 긴 부분 문자열 찾기
        function solution(myString, pat) {
            return myString.slice(0,myString.lastIndexOf(pat)+pat.length);;
        }
        // 빈 배열에 추가, 삭제하기
        function solution(arr, flag) {
            var answer = [];
            
            flag.forEach((el,i) => {
                if(el){
                    for(let j=0; j<arr[i]*2; j++){
                        answer.push(arr[i])
                    }
                }else{
                    for(let j=0; j<arr[i]; j++){
                        answer.pop()
                    }
                }
            })
            return answer;
        }
        // 가운데 글자 가져오기
        function solution(s) {
            var le = s.length;
            return le%2 === 0 ? s.substr(le/2-1,2) : s.substr(Math.floor(le/2),1);
        }
        // 수박수박수박수박수?
        function solution(n) {
            let answer = '';
            return answer.padEnd(n,'수박') 
        }
        // 한 번만 등장한 문자
        function solution(s) {
            var answer = '';
            [...s].forEach(el => {
                if(s.indexOf(el) === s.lastIndexOf(el)){
                    answer += el
                }
            })
            return [...answer].sort().join('');
        }
        // 내적
        function solution(a, b) {
            var answer = 0;
            a.forEach((_,i) => {
                answer += a[i]*b[i]
            })
            return answer;
        }
        // 문자열이 몇 번 등장하는지 세기
        function solution(myString, pat) {
            var answer = 0;

            for(var i=0; i<myString.length; i++){
                if(myString.slice(i).startsWith(pat)){
                    answer ++
                }
            }

            return answer
        }
        // 간단한 논리 연산
        function solution(x1, x2, x3, x4) {
            return (x1||x2) && (x3||x4);
        }
        // 문자열 뒤집기
        function solution(my_string, s, e) {
            const str = my_string.slice(s,e+1);
            const newStr = [...str].reverse().join('');
            return my_string.replace(str, newStr);
        }
        // 배열의 길이를 2의 거듭제곱으로 만들기
        function solution(arr) {
            var answer = [];
            let le = arr.length;

            for(var i=0; i<le; i++){
                if(le <= 2**i){
                    answer = Array(2**i).fill(0);
                    answer.splice(0,le,...arr);
                    break;
                }
            }

            return answer;
        }
        // 이진수 더하기
        function solution(bin1, bin2) {
            var answer = parseInt(+bin1,2) + parseInt(+bin2,2) ;
            return answer.toString(2);
        }
        // 컨트롤 제트
        function solution(s) {
            var answer = 0;
            s = s.split(' ');
            s.forEach((el,i) => {
                if(el === 'Z'){
                    answer -= s[+(i-1)];
                    return
                }
                answer += +el
            })

            return answer;
        }
        // 약수의 개수와 덧셈
        function solution(left, right) {
            var answer = 0;
            
            for(var i=left; i<=right; i++){
                let count = 0;
                for(var j=1; j<=i; j++){
                    if(i%j === 0){
                        count++
                    }
                }
            
                count%2 === 0 ? answer += i : answer -= i
            }
            
            return answer;
        }
        // 문자열 내림차순으로 배치하기
        function solution(s) {
            return [...s].sort().reverse().join('');
        }
        // 세 개의 구분자
        function solution(myStr) {
            var answer =  myStr.split(/[a|b|c]/g).filter(a => a);
            return answer.length ? answer : ["EMPTY"]
        }
        // 수열과 구간 쿼리 4
        function solution(arr, queries) {
            for(let [s,e,k] of queries)
                for(let i=s; i<e; i++){
                    if(i%k ===0) arr[i]++
                }
            return arr;
        }
        // 7의 개수
        function solution(array) {
            var answer = 0;
            array.forEach(el => [...el+''].forEach(el => {
                if(el == 7) answer++ 
            }))
            
            return answer;
        }
        // 소인수분해
        function solution(n) {
            var answer = [];

            const factors = (n) => {
                let count = 2;
                if(n === 0){
                    return
                }
                if(n%count === 0){
                    if(!answer.includes(count)) answer.push(count);

                    return factors(n/count);
                }
                if(n%count != 0){
                    for(let i=count; i<=n; i++){
                        if(n%i === 0){
                            if(!answer.includes(i)) answer.push(i);

                            return factors(n/i);
                        }
                    }
                }
            }

            factors(n)

            return answer;
        }
        // 리스트 자르기
        function solution(n, slicer, num_list) {
            var answer = [];
            const [a,b,c] = slicer;
            switch(n){
                case 1:
                    answer = num_list.slice(0,b+1);
                    break;
                case 2:
                    answer = num_list.slice(a);
                    break;
                case 3:
                    answer = num_list.slice(a,b+1);
                    break;
                case 4:
                    answer = num_list.slice(a,b+1);
                    answer = answer.filter((_,i) => i%c === 0 )
                    break;
            }
            return answer;
        }
        // 공 던지기
        function solution(numbers, k) {
            let count = (k*2-1) // 공을 던지는 횟수
            let le = numbers.length; // 배열의길이
            let index = count%le; // 공을던지는 사람의 index
            
            return count <= le ? count : index === 0 ? numbers[numbers.length-1] : numbers[index-1];
        }
        // 문자열 묶기
        function solution(strArr) {
            array = Array(31).fill(0);
            for (let s of strArr) array[s.length]++
            return Math.max(...answer);
        }
        // 커피 심부름
        function solution(order) {
            var answer = 0;
            for(let s of order){
                if(s.includes('americano')){
                    answer += 4500
                }
                if(s.includes('cafelatte')){
                    answer += 5000
                }
                if(s.includes('anything')){
                    answer += 4500
                }
            }
            return answer;
        }
        // 조건에 맞게 수열 변환하기 2
        function solution(arr) {
            const progression = (array,count) => {
                const newArray = [...array].map(el => {
                    if(el>=50 && el%2===0){
                        return el/2
                    }else if(el<50 && el%2===1){
                        return el*2+1
                    }else{
                        return el
                    }
                })
                if(newArray.join('') == array.join('')){
                    return count
                }else{
                    return progression(newArray, count+=1)
                }
            }
            return progression(arr,0);
        }

        // 2의 영역
        function solution(arr) {
            var firstIndex = arr.indexOf(2);
            var lastIndex = arr.lastIndexOf(2);
            
            if(firstIndex === -1 && lastIndex === -1){
                return [-1]
            }
            return  arr.slice(firstIndex, lastIndex+1);
        }

        // qr 코드
        function solution(q, r, code) {
            return [...code].filter((_,i)=> i%q === r).join('');
        }

        // 잘라서 배열로 저장하기
        function solution(my_str, n) {
            var answer = [];
            for(let i=0; i < my_str.length; i+=n){
                answer.push(my_str.slice(i,i+n))
            }
            
            return answer;
        }

        // 부족한 금액 계산하기
        function solution(price, money, count) {
            let total = 0;
            
            for(let i=1; i<=count; i++){
                total += price*i;
            }
            
            return total > money ? total-money : 0;
        }

        // 문자 개수세기
        function solution(my_string) {
            var answer = new Array(52).fill(0);
            [...my_string].forEach(el => {
                let charCode = el.charCodeAt(0);
                
                if(charCode >= 65 && charCode <= 90){
                    answer[charCode-65] += 1;
                }else{
                    answer[charCode-71] += 1;
                }
            })
            return answer;
        }

        // 문자열 계산하기
        function solution(my_string) {
            return Function(`return ${my_string}`)()
        }

        // 영어가 싫어요
        function solution(numbers) {
            let answer = numbers;
            const wordToNumber = {
                'one': 1,
                'two': 2,
                'three': 3,
                'four': 4,
                'five': 5,
                'six': 6,
                'seven': 7,
                'eight': 8,
                'nine': 9,
                'zero': 0
            };

            for (const key in wordToNumber) {
                answer = answer.replaceAll(key, wordToNumber[key]);
            }
            
            return +answer;
        }

        // 배열 만들기 4
        function solution(arr) {
            var stk = [];
            let i = 0;
            while(i < arr.length){
                const top = stk.length;
                if(top === 0){
                    stk.push(arr[i]);
                    i++;
                }else{
                    if(stk[top-1] < arr[i]){
                        stk.push(arr[i]);
                        i++;
                    }else if(stk[top-1] >= arr[i]){
                        stk.pop();
                    }
                }
            }
            return stk;
        }

        // 문자열 다루기 기본
        function solution(s) {
            const regex = /^[0-9]{4}$|^[0-9]{6}$/;
            return regex.test(s);
        }

        //두수의 합
        function solution(a, b) {
            const num1 = BigInt(a);
            const num2 = BigInt(b);
            
            return (num1 + num2).toString();
        }

        // 구슬을 나누는 경우의 수
        function solution(balls, share) {
            const factorial = (number) => {
                if(number <= 1){
                    return 1
                }
                if(number !== 1){
                    return number * factorial(number-1);
                }
            }
        

            return Math.round(factorial(balls) / (factorial(balls-share) * factorial(share)));
        }

        // 행렬의 덧셈
        function solution(arr1, arr2) {
            var answer = [];
            for(let i=0; i<arr1.length; i++){
                let arrayItme = [];
                for(let j=0; j<arr1[i].length; j++){
                    arrayItme.push(arr1[i][j] + arr2[i][j]);
                }
                answer.push(arrayItme);
            }
            
            return answer;
        }

        // 최댓값과 최솟값
        function solution(s) {
            var answer = s.split(' ').map(el => +el);
            return `${Math.min(...answer)} ${Math.max(...answer)}`;
        }

        // 왼쪽 오른쪽
        function solution(str_list) {
            var answer = [];
            for(let i = 0; i<str_list.length; i++){
                if(str_list[i] === 'l') return str_list.slice(0,i); 
                if(str_list[i] === 'r') return str_list.slice(i+1);
            }
            return answer;
        }

        // 배열 만들기 6
        function solution(arr) {
            const stk = []; 
            arr.forEach((el,i)=>{
                const len = stk.length;
        
                if(len === 0){
                    stk.push(el);
                }
                if(len > 0){
                    if(stk[len-1] === el){
                        stk.pop();
                    }else{
                        stk.push(el);
                    }
                }
            })

            return stk.length > 0 ? stk : [-1];
        }
        
        // 삼각형의 완성조건
        function solution(sides) {
            var answer = 0;
            const [one , two] = sides;

            for(let i=1; i<one+two; i++){
                const newSides = [...sides,i].sort((a,b) => a-b);
                if(newSides[2] < newSides[1] + newSides [0]) answer++;
            }

            return answer;
        }

        // 문자열 여러번 뒤집기
        function solution(my_string, queries) {
            var answer = my_string;

            queries.forEach(el => {
                const [one , two] = el;
                const string = answer.slice(one,two+1);
                const reverse_string = [...string].reverse().join('');

                answer = answer.slice(0, one) + reverse_string + answer.slice(two + 1);;
            })

            return answer;
        }

        // 수열과 구간쿼리 2
        function solution(arr, queries) {
            var answer = [];

            for(const item of queries){
                const [s,e,k] = item;
                const filterList = [];

                for(let i=s; i<=e; i++){
                    if(arr[i] > k) filterList.push(arr[i]);
                }

                if(filterList.length === 0){
                    answer.push(-1);
                    continue
                }
                answer.push(Math.min(...filterList));
            }

            return answer;
        }

        // 조건 문자열
        function solution(ineq, eq, n, m) {
            let condition = '';
            if(eq === '!') condition = n+ineq+m;
            if(eq === '=') condition = n+ineq+eq+m;
            answer = Function(`return ${condition}`)();

            return answer ? 1 : 0;
        }
        // 무작위로 k 개의 개수 뽑기
        function solution(arr, k) {
            var answer = [...new Set(arr)].slice(0,k);
            while(answer.length < k){
                answer.push(-1);
            }
            return answer;
        }
        // 정사각형으로 만들기
        function solution(arr) {
            var answer = [...arr];
            const col = arr.length;
            const row = arr.reduce((max,column) => Math.max(max , column.length) , 0)
            if( col > row){
                answer = answer.map( item => {
                    let newItem = [...item];
                    while(newItem.length < col){
                        newItem.push(0);
                    }
                    return newItem;
                })
            }
            if(row > col){
                let newArr = new Array(row).fill(0);
                for(let i = col; i < row; i++){
                    answer.push(newArr);
                }
            }

            return answer;
        }
        // 최대공약수와 최소공배수
        function solution(n, m) {
            var answer = [];
            function gcd(n, m) {
                if (m === 0) {
                    return n;
                } else {
                    return gcd(m, n % m);
                }
            }
            function lcm(n, m) {
                return (n * m) / gcd(n, m);
            }
            answer[0] = gcd(n,m);
            answer[1] = lcm(n,m);
            return answer;
        }
        // 최솟값 만들기
        function solution(A,B){
            var answer = 0;
            let a = A.sort((a,b) => b-a);
            let b = B.sort((a,b) => a-b);
            while(a.length > 0){
                answer += a[a.length-1] * b[b.length-1];
                a.pop();
                b.pop();
            }
            return answer;
        }

        // 올바른 괄호
        function solution(s){
            var stack = [];
            for(let char of s){
                if(char === '('){
                    stack.push(char);
                }else if( char === ')' && stack.length > 0){
                    stack.pop();
                }else{
                    return false;
                }

            }
            return stack.length === 0;
        }
        // 그림 확대
        function solution(picture, k) {
            let answer = [];
            picture.forEach(el => {
                let item = [...el];
                item = item.map(el => el.repeat(k)).join('');
                for(let i = 0; i < k ; i++){
                    answer.push(item);
                }
            });

            return answer
        }
        // 이진 변환 반복하기
        function solution(s) {
            let answer = [0,0];
            while (s != '1') {
                s = [...s].filter(el => {
                    if (el === '0') answer[1]++;
                    return +el;
                }).join('').toString(10).length.toString(2);
                answer[0]++;
            }
            return answer;
        }
        // PCCP 모의고사 1회 외톨이 알파벳
        function solution(str) {
			var uniqueStr = [...new Set(str.trim())];
			var soloStrings = [];

			for (var i = 0; i < uniqueStr.length; i++){
				var regex = new RegExp(`${uniqueStr[i]}*`, 'g');
				
				if (str.match(regex).filter(Boolean).length > 1) soloStrings.push(uniqueStr[i]);
			}
			
			return  soloStrings.length > 0 ? soloStrings.sort().join('') : "N";
		}
        // PCCP 모의고사 1회 체육대회
        function solution(ability) {
            let answer = 0;

            function DFS(L, s, ability, check) {
                const n = ability.length; // 학생 수
                const m = ability[0].length; // 종목 개수

                if (L === m) {
                    answer = Math.max(answer, s); // 능력치 합의 최댓값을 구함
                } else {
                    for (let i = 0; i < n; i++) {
                        if (check[i] === 0) {
                            check[i] = 1;
                            DFS(L + 1, s + ability[i][L], ability, check);
                            check[i] = 0;
                        }
                    }
                }
            }

            const check = new Array(ability.length).fill(0);
            DFS(0, 0, ability, check);
            return answer;
        }
        // PCCP 모의고사 1회 유전법칙
        function solution(queries) {
            var answer = [];

            function bean(generation, order) {
                if (generation === 1) return 'Rr';

                const parent = bean(generation - 1, Math.floor((order-1)/ 4) + 1);

                if (parent === "RR" || parent === "rr") return parent;

                if (order % 4 === 0) {
                    return 'rr';
                } else if (order % 4 === 1) {
                    return 'RR';
                } else {
                    return 'Rr';
                }
            }

            for(let query of queries){
                answer.push(bean(query[0] , query[1]));
            }

            return answer;
        }
        // 같은 숫자는 싫어!
        function solution(arr){            
            return arr.filter((val , index) => val != arr[index+1]);
        }
        // 외계 언어 해석
        function solution(spell, dic) {
            var answer = 2;
            let check = spell.sort().join('');

            dic.forEach((el)=> {
                el = [...el].sort().join('');
                console.log(el,check);
                if(check === el){
                    answer = 1;
                }
            })

            return answer;
        }
        // 문자열 겹쳐쓰기
        function solution(my_string, overwrite_string, s) {
            var answer = [...my_string]
            answer.splice(s,overwrite_string.length,...overwrite_string);
            return answer.join("");
        }
        // 종이 자르기
        function solution(M, N) {
            var answer = M*N-1;
            return answer;
        }
        // 직사각형 넓이 구하기
        function solution(dots) {
            // x와 y 좌표 값의 최소값과 최대값 찾기
            let minX = dots[0][0];
            let minY = dots[0][1];
            let maxX = dots[0][0];
            let maxY = dots[0][1];

            for (let i = 1; i < dots.length; i++) {
                const [x, y] = dots[i];
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }

        // 직사각형의 넓이 계산
            const area = (maxX - minX) * (maxY - minY);

            return area;
        }       
        // 캐릭터의 좌표
        function solution(keyinput, board) {
            var answer = [0,0];
            const [maxX , maxY] = board.map(el => Math.floor(el/2));
            
            keyinput.forEach(input => {
                if(input == 'left' && answer[0] > -maxX){
                    answer[0]--;
                }
                if(input == 'right' && answer[0] < maxX){
                    answer[0]++;
                }
                if(input == 'up' && answer[1] < maxY){
                    answer[1]++;
                }
                if(input == 'down' && answer[1] > -maxY){
                    answer[1]--;
                }
            })

            return answer;
        }
        // 3진법 뒤집기
        function solution(n) {
            let answer = [...n.toString(3)].reverse().join('');
            return parseInt(answer , 3);
        }
        // 로그인 성공?
        function solution(id_pw, db) {
            let answer = 'fail'
            const [id, pw] = id_pw;
            
            for (let info of db) {
                if (id === info[0] && pw === info[1]) {
                    answer = 'login';
                    break;
                } else if (id === info[0]) {
                    return 'wrong pw';
                }
            }
            
            return answer;
        } 
        // 숫자의 표현
        function solution(n) {
            let answer = 0;
            
            for (let i = 1; i <= n; i++) {
                let sum = 0;
                
                for (let j = i; j <= n; j++) {
                    sum += j;
                    if (sum === n) {
                        answer++;
                        break;
                    } else if (sum > n) {
                        break;
                    }
                }
            }
            
            return answer;
        }
        // 예산
        function solution(d, budget) {
            const budgetApply = d.sort((a,b)=>a-b).filter(v=>{
                if(budget - v >= 0){
                    budget -= v
                    return true
                }
                return false
            })

            return budgetApply.length
        }
        // 이상한 문자 만들기
        function solution(s) {
            var answer = s.split(' ');
            answer = answer.map(el =>{
                let newS = [...el].map((el,i) => {
                    if(i % 2 === 1){
                        return el.toLowerCase();
                    }
                    return el.toUpperCase();
                }).join('');
                return newS
            }).join(' ');

            return answer;
        }
        // 치킨 쿠폰
        function solution(chicken) {
            let answer = 0;

            const chickenCount = (chicken , service , coupone) => {
                let newChicken = Math.floor(chicken/10);
                service += Math.floor(chicken/10);
                coupone += chicken%10;
                
                if(coupone >= 10){
                    newChicken++;
                    service++;
                    coupone = coupone%10
                }
                
                if(chicken < 10 && coupone <10){
                    return service
                }

                return chickenCount(newChicken , service , coupone) 
                
            }
            
            answer = chickenCount(chicken,0,0);
            return answer;
        }
        // 다음 큰 숫자
        function solution(n) {
            let m = n;
            while(true){
                m++;
                if(m.toString(2).replaceAll(/0/g, '').length === n.toString(2).replaceAll(/0/g, '').length) return m;
            }
        }
        // 크기가 작은 부분 문자열
        function solution(t, p) {
            var answer = 0;
            const tLen = t.length;
            const pLen = p.length;

            for(let i = 0; i <= tLen - pLen; i++){
                if(+t.slice(i,i+pLen) <= +p) answer++;

            }
            
            return answer;
        }
        // 삼총사
        function solution(number) {
            var answer = 0;

            const DFS = (start , SumArr) => {
                console.log(start,SumArr);
                if(SumArr.length === 3){
                    const sum = SumArr.reduce((acc,cur) => acc + cur , 0);
                    if(sum === 0){
                        answer++;
                    }
                    return
                }

                for(let i = start; i<number.length; i++){
                    DFS(i+1 , [...SumArr , number[i]]);
                }
            
            }

            DFS(0,[]);

            return answer;
        }
        // 저주의 숫자 3
        function solution(n) {
            var answer = 0;
            for(let i = 1; i<n; i++){
                if(i%3 === 0 || (""+i).match(/3/)) answer++;
            }
            answer += n;
            
            for(let i=n; i<=answer; i++){
                if(i%3 === 0 || (""+i).match(/3/)) answer++;
            }

            return answer;
        }
        // 피보나치 수
        function solution(n){
            let pibo = [BigInt(0),BigInt(1)];

            for(let i = 2; i<=n; i++){
                pibo[i] = pibo[i-1] + pibo[i-2];
            }
            return pibo[n]% BigInt(1234567);
        }
        // 최소 직사각형
        function solution(sizes) {
            let garo = [];
            let sero = [];
            sizes.forEach(el => {
                if(el[0] < el[1]){
                    let temp = el[0];
                    el[0] = el[1];
                    el[1] = temp;
                }
                garo.push(el[0]);
                sero.push(el[1]);
            })

            return Math.max(...garo) * Math.max(...sero);
        }
        // 전국 대회 선발고사
        function solution(rank, attendance) {
            var answer = rank.filter((_, index) => attendance[index]).sort((a,b) => a-b);
            const a = rank.findIndex(el => el === answer[0])*10000;
            const b = rank.findIndex(el => el === answer[1])*100;
            const c = rank.findIndex(el => el === answer[2]);
            return a+b+c;
        }
        // 시저암호
        function solution(s, n) {
            var answer = [...s].map(el => {
                if(el === ' '){
                    return el;
                }

                let char = el.charCodeAt()+n;

                if(/[a-z]/.test(el) && char > 'z'.charCodeAt()){
                    char -= 26;
                }else if(/[A-Z]/.test(el) && char > 'Z'.charCodeAt()){
                    char -= 26;
                }

                return String.fromCharCode(char);
            });

            return answer.join('');
        }
        // 문자열 밀기
        function solution(A, B) {
            var answer = -1;

            if(A === B){
                return 0;
            }
            
            let originString = A;
            for(let i=0; i<A.length; i++){
                let checkString = [...originString];
                const str = checkString.pop();

                checkString.unshift(str);
                checkString = checkString.join('');
                originString = checkString;
                
                if(checkString === B){
                    answer = i+1;
                    break;
                }
            }

            return answer;
        }
        // 특이한 정렬
        function solution(numlist, n) {
            var answer = numlist.sort((a,b) => {
                if(Math.abs(n-a) === Math.abs(n-b)){
                    return a>b ? -1 : 1;
                }

                return Math.abs(n-a) > Math.abs(n-b) ? 1 : -1
            });

            return answer;
        }
        // 짝지어 제거하기
        function solution(s){
            const stack = []
            for(let i=0;i<s.length;i++){
                if(stack[stack.length - 1] === s[i]){
                    stack.pop()
                }
                else{
                    stack.push(s[i])
                }
            }

            return stack.length === 0 ? 1 : 0
        }
        // 배열 만들기 2
        function solution(l, r) {
            let result = [];
            
            function isZeroAndFiveOnly(num) {
                const numStr = num.toString();
                for (let char of numStr) {
                    if (char !== '0' && char !== '5') {
                        return false;
                    }
                }
                return true;
            }
            
            
            for (let i = l; i <= r; i++) {
                if (isZeroAndFiveOnly(i)) {
                    result.push(i);
                }
            }

            return result.length > 0 ? result : [-1];
        }
        // PCCP 모의거사 2회 실습용 로봇
        function solution(command) {
            var answer = [0,0];
            const Direction = 'NESWNESW';
            let head = 'N';
            
            [...command].forEach(move => {
                if(move === 'R'){
                    head = Direction[Direction.indexOf(head)+1];
                }
                if(move === 'L'){
                    head = Direction[Direction.lastIndexOf(head)-1]
                }

                if(move === 'G'){
                    if(head === 'N') answer[1] = answer[1]+1;
                    if(head === 'E') answer[0] = answer[0]+1;
                    if(head === 'S') answer[1] = answer[1]-1;
                    if(head === 'W') answer[0] = answer[0]-1;
                }
                if(move === 'B'){
                    if(head === 'N') answer[1] = answer[1]-1;
                    if(head === 'E') answer[0] = answer[0]-1;
                    if(head === 'S') answer[1] = answer[1]+1;
                    if(head === 'W') answer[0] = answer[0]+1;
                }
                
                
            })
            
            return answer;
        }
        // PCCP 모의고사 2회 카페 확장
        function solution(menu, order, k) {
            const queue = [];
            let max = 0;
            let time = 0;
            
            while(order.length > 0 || queue.length > 0){
                if(time === 0){
                    queue.push(menu[order.shift()]);
                    time++;
                    continue;
                }

                if(time%k === 0 && order.length > 0){
                    queue.push(menu[order.shift()] + (queue.length > 0 ? queue[queue.length-1] : time));  
                } 
                if(queue[0] <= time && queue.length > 0) queue.shift();

                max = Math.max(max, queue.length);
                time++
            }
            
            return max;
        }
        //카펫
</script>
</body>
</html>